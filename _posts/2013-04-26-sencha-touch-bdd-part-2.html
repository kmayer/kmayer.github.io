---
layout: theme:post
title: Sencha Touch BDD Part 2
date: 2013-04-26 14:51:42.000000000 -07:00
tags:
- bdd
- jasmine
- javascript
- mobile
- Sencha Touch
- unit testing
---
<h1 id="senchatouchbdd">Sencha Touch BDD</h1>

<h2 id="tldr">tl;dr</h2>

<p>A multi-part series of articles on how to test Sencha Touch applications. It uses Jasmine for unit testing and Siesta for integration testing.</p>

<h2 id="part2--unittestingmodels">Part 2 &ndash; Unit Testing Models</h2>

<p>In <a href="{% post_url 2013-04-17-sencha-touch-bdd-part-1 %}" title="Sencha Touch BDD Part 1">Part 1</a> I showed you how to set up your Sencha Touch development environment to use the <a href="http://pivotal.github.com/jasmine">Jasmine</a> JavaScript test framework. We’re going to take a bit of a breather from all the hard work we did last week. In this blog, I’m going to show you how to test simple models.</p>

<h3 id="letshavesomefunshallwe">Let’s have some fun, shall we?</h3>

<p>Test-Driven-Development starts with a test, of course. Let’s write one that just asserts that our model class <em>exists</em>:</p>

{% highlight js %}
$ cat spec/javascripts/model/MyModelSpec.js
describe('SenchaBdd.model.MyModel', function() {
  it('exists', function() {
    var model = Ext.create('SenchaBdd.model.MyModel');
    expect(model.$className).toEqual('SenchaBdd.model.MyModel');
  });
});
{% endhighlight %}

<p>When we run our tests in the browser, Jasmine reports this:</p>

<pre>
  Error: [Ext.Loader] Failed loading synchronously via XHR: 'app/model/MyModel.js';
  please verify that the file exists. XHR status code: 404
</pre>

<p>Which is just Ext’s very formal way of saying, &#8220;No such class exists&#8221; because we haven’t written it, yet.</p>

<p>Let’s write one that makes the test pass:</p>

{% highlight js %}
$ cat app/model/MyModel.js
Ext.define('SenchaBdd.model.MyModel', {
  extend: 'Ext.data.Model'
});
{% endhighlight %}

<p>We have proven that we can create a new class, and that it’s name is what we expect.</p>

<h3 id="attributes">Attributes</h3>

<p>Let’s assert that our model has some attributes:</p>

{% highlight js %}
$ cat spec/javascripts/model/MyModelSpec.js
it('has data', function () {
  var model = Ext.create('SenchaBdd.model.MyModel', {
    name: 'Test',
    email: 'test@example.com',
    favoriteColor: 'blue'
  });
  expect(model.get('name')).toEqual('Test');
  expect(model.get('email')).toEqual('test@example.com');
  expect(model.get('favoriteColor')).toEqual('blue');
});
{% endhighlight %}


<p>Which of course, fails, until we add some fields to our model:</p>

{% highlight js %}
$ cat app/model/MyModel.js
Ext.define('SenchaBdd.model.MyModel', {
  extend: 'Ext.data.Model',
  config: {
    fields: [
      { name: 'name', type: 'string' },
      { name: 'email', type: 'string' },
      { name: 'favoriteColor' }
    ]
  }
});
{% endhighlight %}

<h3 id="defaultvalues">Default values</h3>

<p>Let’s say that our model has some default values</p>

{% highlight js %}
$ cat spec/javascripts/model/MyModelSpec.js
it('has default values', function() {
  var model = Ext.create('SenchaBdd.model.MyModel')
  expect(model.get('favoriteColor')).toEqual('yellow');
})
{% endhighlight %}


<p>Reload the Jasmine runner in the browser and &#8230;</p>

<pre>
  SenchaBdd.model.MyModel has default values.
  Expected undefined to equal 'yellow'.
</pre>

<p>Which is easily resolved by adding it to the class:</p>

{% highlight js %}
$ cat app/model/MyModel.js
{ name: 'favoriteColor', defaultValue: 'yellow' }
{% endhighlight %}

<h3 id="validations">Validations</h3>
<p>One last simple piece, let’s assert that email is a <em>required</em> field.</p>

{% highlight js %}
$ cat spec/javascripts/model/MyModelSpec.js
it('requires an email address', function() {
  var model = Ext.create('SenchaBdd.model.MyModel');
  var errors = model.validate();
  expect(errors.isValid()).toBeFalsy();

  expect(errors.getByField('email')[0].getMessage()).toEqual('must be present');
})
{% endhighlight %}


<p>The first expectation asserts that the model is not <em>valid</em> at all. It’s a gatekeeper test. The second test asserts that there’s validation error on the email field (and not some other field).</p>

{% highlight js %}
$ cat app/model/MyModel.js
  config: {
    ...
    validations: [
      { field: 'email', type: 'presence' }
    ]
{% endhighlight %}

<h2 id="roundup">Roundup</h2>

<p>This is a pretty simple set of tests. If you are at all familiar with unit testing, you won’t find much new here. Testing for validations by inspecting on the Errors collection was a little tricky to suss out. Hopefully I’ve saved you a few frustrating moments digging through the source code. What’s also interesting, I think, is how the test report <em>reads</em>:</p>

<pre>
  SenchaBdd.model.MyModel
    exists
    has data
    has default values
    requires an email address
</pre>

<p>The test <em>itself</em> communicates something to the reader about the <em>intention</em> of the model. That’s a key concept to understand about TDD; the most important and expensive reader of the application is not the <em>browser</em>, it’s the <em>person</em> who reads and maintains it. It might be your successor or your team mate, or perhaps, yourself, six months from now, when you’ve forgotten everything about this particular patch of code.</p>
