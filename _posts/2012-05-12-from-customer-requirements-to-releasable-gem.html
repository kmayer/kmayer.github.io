---
layout: post
title: From customer requirements to releasable gem
date: 2012-05-12 14:39:15.000000000 -07:00
categories:
- Work
tags:
- cucumber
- FOSS
- ruby
- testing
---
<p>One of the many pleasures of working at Pivotal Labs is that we are encouraged to release some of our work as open source. Often during the course of our engagements, we write code that might have wide-spread use. Due to the nature of our contracts, we can not unilaterally release such code. Those rights belong to the client. And rightly so. So, it is an even greater pleasure when one of our clients believes in "giving back" to the community, as well. </p>
<p>One such example is this modest gem, <code>attribute_access_controllable</code> which allows you to set read-only access at the <em>attribute</em> level, on a per-instance basis. For example, let's say that you have a model <code>Person</code> with an attribute <code>birthday</code>, which, for security purposes, cannot be changed once this attribute is set &#040;except, perhaps, by an administrator with extraordinary privileges&#041;. Any future attempts to change this attribute will result in a validation error.</p>
<p>e.g.</p>
<pre><code>&gt; alice = Person.new&#040;:birthday =&gt; '12/12/12'&#041;
=&gt; #&lt;Person id: nil, attr1: nil, created_at: nil, updated_at: nil, read_only_attributes: nil, birthday: "0012-12-12"&gt;
&gt; alice.attr_read_only&#040;:birthday&#041;
=&gt; #&lt;Set: {"birthday"}&gt;
&gt; alice.save!
=&gt; true
&gt; alice.birthday = "2012-12-12"
=&gt; "2012-12-12"
&gt; alice.save!
ActiveRecord::RecordInvalid: Validation failed: Birthday is invalid, Birthday is read_only
&gt; alice.save!&#040;:skip_read_only =&gt; true&#041;
=&gt; true
</code></pre>
<p>Setting this up is trivial, thanks to a Rails generator which does most of the heavy lifting for you.</p>
<pre><code>rails generate attribute_access Person
</code></pre>
<p>After that, you need only know about one new method added to your class:</p>
<pre><code>#attr_read_only&#040;*attributes&#041; # Marks attributes as read-only
</code></pre>
<p>There are a few others, but this one, plus the new functionality added to <code>#save</code> and <code>#save!</code> will get you quite far.</p>
<p>And if that's all that you were looking for when you stumbled across this article, then there's no need to read any further. Go install the gem and have fun &#040;and may your tests be green when you expect them to be&#041;.</p>
<h2>From customer requirements to releasable gem</h2>
<p>On the other hand, if you are interested in how we got from the original customer story to a releasable open sourced gem, read on. The source code for the module is a <a href="https://github.com/halogenguides/Attribute-Access-Controllable/blob/master/lib/attribute_access_controllable.rb">mere 34 lines long</a>. It implements 2 new methods, a validator and &#040;gently&#041; overrides <code>#save</code> and <code>#save!</code>. Being good Test Driven Developers, we wrote our specs first, and since we wanted this behavior to be included in several models, we wrote our specs as a <a href="https://github.com/halogenguides/Attribute-Access-Controllable/blob/master/lib/attribute_access_controllable/spec_support/shared_examples.rb"><em>shared behavior</em></a> as well. The spec clocks in at 44 lines, slightly longer than our implementation. All in all, tiny. The whole commit was less than 100 lines of code.</p>
<pre><code>AttributeAccessControllable
  it should behave like it has AttributeAccessControllable
    #attr_read_only&#040;:attribute, ...&#041; marks an attribute as read-only
    #read_only_attribute?&#040;:attribute&#041; returns true when marked read-only
    #read_only_attribute?&#040;:attribute&#041; returns false when not marked read-only &#040;or not marked at all&#041;
    #save! raises error when :attribute is read-only
    #save!&#040;:context =&gt; :skip_read_only&#041; is okay
    #save is invalid when :attribute is read-only
    #save&#040;:context =&gt; :skip_read_only&#041; is okay
</code></pre>
<p>In order to get to something "releasable" we needed a few more things, which we put on our To-Do list:</p>
<h4>To do</h4>
<ol>
<li>MIT License</li>
<li>A gem specification</li>
<li>Basic documentation in a README file</li>
</ol>
<p>The list got longer as we fleshed out both the documentation and the integration tests, as you'll see in a moment, but first, let's talk about</p>
<h3>Getting the legal issues resolved</h3>
<p>Pivotal's open sourcing policy is straightforward and simple to execute; We don't touch it. We write code for our clients, it's their code to do with as they please. My particular client liked the work we did for them and thought it would make a great open source gem. The Director of Engineering signed off on the idea and I paired with him to create the github repository during a lunch break. The first commit was tiny, just a basic directory structure and the existing code. I don't think the tests passed because they lacked a proper RSpec infrastructure.</p>
<h3>Creating the gem</h3>
<pre><code>bundler gem DIRECTORY
</code></pre>
<p>is your best friend. It set up the layout for us, including an MIT License and a gem specification. It had a boilerplate README, too.</p>
<h3>Writing the documentation for the code you wished you had</h3>
<p>Next, we wrote a draft of the README file which documented what we knew: You needed a migration to create a column called <code>:read_only_attributes</code> and you needed to include the module into the class. Then we started thinking about the pain points of using our code as is. Wouldn't it be nice if we could create the migration automatically? Rails generators do that sort of thing, how hard could it be? &#040;Famous last words...&#041; It became clear that we needed to test drive out some new features of the <em>gem</em> that supported the actual <em>module</em>.</p>
<h4>To do</h4>
<ol>
<li><strike>MIT License</strike></li>
<li><strike>A gem specification</strike></li>
<li><strike>Basic documentation in a README file</strike></li>
<li>Integration test</li>
</ol>
<h3>I am not a big cucumber fan, but...</h3>
<p>Really, I'm not. I used to write Cucumber features all the time, but nowadays, I use a combination of RSpec and Capybara to get most of my day-to-day integration testing done. There is, however, one sweet spot for Cucumber that I'm finding more and more useful; A very high-level document that describes essential features in a way that a reader will say, "Ahhh, so <em>that</em> is how it is supposed to work!" Here's a copy of the spec I wrote:</p>
<pre><code>Feature: Read only attributes

Scenario: In a simple rails application
  Given a new rails application
  And I generate a new migration for the class "Person"
  And I generate an attribute access migration for the class "Person"
  And I have a test that exercises read-only
  When I run `rake spec`
  Then the output should contain "7 examples, 0 failures"
</code></pre>
<p>You probably won't find any web-steps out there to handle these lines. I use <a href="https://github.com/cucumber/aruba">Aruba</a> to handle the dirty work of executing shell commands in a safe sandbox-y way. The <a href="https://github.com/halogenguides/Attribute-Access-Controllable/blob/master/features/step_definitions/steps.rb">step definition file</a> hides most of the ugliness. Even so, most readers could figure out what to do, by hand, for each step.</p>
<h4>To do</h4>
<ol>
<li><strike>MIT License</strike></li>
<li><strike>A gem specification</strike></li>
<li><strike>Basic documentation in a README file</strike></li>
<li><strike>Integration test</strike></li>
<li>Generator</li>
</ol>
<h3>Big generators</h3>
<p>This gem was my first attempt at writing a generator, so it was awkward. I still don't understand <a href="https://github.com/wycats/thor">Thor</a> properly. Fortunately, I happened upon <a href="https://github.com/alexrothenberg/ammeter">Ammeter</a>, which helped me write out test specs for the generator. If you've got good specs, then you can sometimes stumble along until you learn enough to get it right. Alex Rothenberg's original <a href="http://www.alexrothenberg.com/2011/10/10/ammeter-the-way-to-write-specs-for-your-rails-generators.html">blog post</a> about the gem was quite informative, as were the test cases from the <a href="https://github.com/plataformatec/devise/tree/master/test/generators">Devise</a> gem.</p>
<p>I have to admit; constructing the generator was more complex than the original module! There are more "moving parts;" templates, usage files, specs, in addition to the generator itself. So there is a certain amount of overhead that might overwhelm the original content. On the other hand, I learned quite a bit, and the gem is far more useful.</p>
<pre><code>require "spec_helper"
require 'generators/attribute_access/attribute_access_generator'

describe AttributeAccessGenerator do
  before do
    prepare_destination
    Rails::Generators.options[:rails][:orm] = :active_record
  end

  describe "the migration" do
    before { run_generator %w&#040;Person&#041; }
    subject { migration_file&#040;'db/migrate/create_people.rb'&#041; }
    it { should exist }
    it { should be_a_migration }
    it { should contain 'class CreatePeople &lt; ActiveRecord::Migration' }
    it { should contain 'create_table :people do |t|'}
    it { should contain 't.text :read_only_attributes'}
  end

  describe "the class" do
    before { run_generator %w&#040;Person&#041; }
    subject { file&#040;'app/models/person.rb'&#041; }
    it { should exist }
    it { should contain 'include AttributeAccessControllable' }
  end
</code></pre>
<p>Some interesting things to note; you must <code>require</code> the generator, since it is not pulled in by default. The subject of each suite is a <em>file</em>, not the class <code>AttributeAccessGenerator</code>. The <code>migration_file</code> helper prepends the TIMESTAMP onto the migration file for you. If you need to set up more things for your test, <code>destination_root</code> is a helper with a path to the temporary directory. It remains after the tests have run, which makes it useful when debugging.</p>
<p>Here's something else that I did not know, but it might help new generator writers; the order in which you define your methods in the generator class is <em>significant</em>. I don't know how this is done, but each "method" in the generator class is executed in turn. This is important for my generator; the model class definition <em>must</em> exist before I inject the new content that mixes in the module, so I had to write the <code>generate_model</code> method before the <code>inject_attribute_access_content</code> method. I was scratching my head over that one for quite awhile.</p>
<pre><code>require "rails/generators/active_record"

class AttributeAccessGenerator &lt; ActiveRecord::Generators::Base
  source_root File.expand_path&#040;'../templates', __FILE__&#041;

  def create_migration_file
    if &#040;behavior == :invoke &amp;&amp; model_exists?&#041;
      migration_template "migration.rb", "db/migrate/add_read_only_attributes_to_#{table_name}"
    else
      migration_template "migration_create.rb", "db/migrate/create_#{table_name}"
    end
  end

  def generate_model
    invoke "active_record:model", [name], :migration =&gt; false unless model_exists? &amp;&amp; behavior == :invoke
  end

  def inject_attribute_access_content
    class_path = class_name.to_s.split&#040;'::'&#041;

    indent_depth = class_path.size
    content = "  " * indent_depth + 'include AttributeAccessControllable' + "n"

    inject_into_class&#040;model_path, class_path.last, content&#041;
  end
</code></pre>
<h4>To do</h4>
<ol>
<li><strike>MIT License</strike></li>
<li><strike>A gem specification</strike></li>
<li><strike>Basic documentation in a README file</strike></li>
<li><strike>Integration test</strike></li>
<li><strike>Generator</strike></li>
<li>Shareable tests</li>
</ol>
<h2>Yo, I hear you like tests in your tests</h2>
<p>Lastly, we want to share the testing love. The gem consumer should not have to <em>write</em> tests to drive out the same feature that we have already tested. That would not be very DRY. So, in order to make our shared behavior, er, um, <em>shareable</em>, we moved it into <code>lib</code> with a few wrappers, namely, the <code>spec_support.rb</code> file, which you can include in your own spec files to test drive adding the module to your own classes.</p>
<p>Which is where <code>And I have a test that exercises read-only</code> comes in. You can see this in the <code>steps.rb</code> file:</p>
<pre><code>require 'spec_helper'
require 'attribute_access_controllable/spec_support'

describe Person do
  it_should_behave_like "it has AttributeAccessControllable", :attr1
end
</code></pre>
<h4>To do</h4>
<ol>
<li><strike>MIT License</strike></li>
<li><strike>A gem specification</strike></li>
<li><strike>Basic documentation in a README file</strike></li>
<li><strike>Integration test</strike></li>
<li><strike>Generator</strike></li>
<li><strike>Shareable tests</strike></li>
</ol>
<h2>Don't be afraid to release v1.0.0</h2>
<p>I am a strong believer in <a href="http://semver.org/">semantic versioning</a>. I simply can not understand why some core ruby tools are still living in version zero land, even after years and years of development and use. So, after a couple of internal commits, we released v1.0.0 of the gem, and less than a day later released v1.1.0 and then v1.1.1! &#040;You probably shouldn't use anything less than v1.1.1&#041;</p>
<h2>An interesting mix</h2>
<p>In summary, we used a lot of tools and techniques to go from a simple commit to a shareable gem:</p>
<ul>
<li>Rails generators</li>
<li>Cucumber</li>
<li>Aruba</li>
<li>Ammeter</li>
<li>RSpec shared behaviors</li>
<li>Integration tests</li>
<li>Generator tests</li>
<li>Module tests</li>
</ul>
<p>I encourage everyone to release as much of their work as possible because it raises the state of the art for us all. There are limits, of course, but that still affords lots of wiggle room. Small gems like <code>attribute_access_controllable</code> won't change the world, but they ease the pain of staying DRY and we all get to learn a little something.</p>
<h3>Thanks</h3>
<p>To Social Chorus for choosing to open source this code. And to Pivotal Labs for encouraging a better way to do software engineering.</p>
